# Любительская НИР: Сравнение встроенного DSP блока кристалла xilinx и умножителя с деревом Уоллеса 

## 1) Разбор работы DSP слайса

## 2) Умножитель на алгоритме дерева Уоллеса (реализация, количественная оценка результата)

Умножитель Уоллеса использует однобитные полусумматоры и полные сумматоры как представлено на картинке. Получается, что, используя только такие элементы, за 5 шагов можно упростить сумму из 8 слагаемых до 2 слагаемых (5-й этап), после чего результат может быть найден как сумма двух оставшихся слагаемых. Такая реализация позволяет сэкономить в аппаратуре, используя однобитные сумматоры вместо полных многобитных, а так же может быть конвейеризированна, если между этапами разместить регистры.

![image](https://github.com/ShevtsovNikita/multipliers/assets/116370315/184272d9-edee-48e7-8325-c603b148af65)

На рисунке сверху представлено дерево Уоллеса для умножения операндов с разрядностью 8 бит каждый. Аналогичные вычислительные "деревья" можно составить для множителей разрядности 16х16 и 32х32, но они будут слишком громоздкими. Вычислять произведение двух операндов буду следующим образом: сначала разобью каждый операнд на 4 байта, затем попарно перемножу эти байты (получу 16 промежуточных результатов), и сложу результаты с соответствующим смещением.

То есть задача следующая:

 а) реализовать умножитель 8х8 бит, работающий по алгоритму дерева Уоллеса - [wallace_8x8.sv](wallace_8x8.sv)
 
 б) сделать на базе этого умножителя умножитель для 32-битных операндов - [wallace.sv](wallace.sv)

 в) написать тестовое окружение для написанного умножителя Уоллеса - [w32x32_tb.sv](w32x32_tb.sv)
 Для тестового окружения с помощью Python были сгенерированы выборки случайных значений A и B, а также эталонных результатов их умножения. Скрипт [main.py](main.py) генерирует названные выборки и записывает их в файл в формате, который будет воспринят директивой $readmemb в Vivado.
 
## 3) Чтобы было с чем сравнивать производительность умножителя Уоллеса, реализую еще один вариант умножения
Этот умножитель представляет из себя буквально следующее:

![image](https://github.com/ShevtsovNikita/multipliers/assets/116370315/8f425a3b-0c3c-48a9-bd2d-b66a84b72916)

Каждый промежуточное значение ab[i] - логическое "И" a[i] и b[31:0]. И складываем 32 значения ab[0:31] в одном такте. Сделал такой вариант для того, чтобы было с чем сравнивать по критическому пути и аппаратным затратам реализацию умножителя с деревом Уоллеса (потому что с dsp-блоком, очевидно, сравнивать было бы глупо)
